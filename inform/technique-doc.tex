\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr,graphicx}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}

\newcommand{\materia}{[75.41] Taller de Programación I}
\newcommand{\trabajo}{Documentación técnica}
\newcommand{\trabajoheader}{Ejercicio final }
\newcommand{\cuatri}{1c2019}
\newcommand{\cuatrimestre}{Primer cuatrimestre de 2019}
\newcommand{\grupo}{Grupo 3}

\newcommand{\autores}{
	Camila Bojman,
	Cecilia Hortas,
	Nicolas Vazquez}

\hypersetup{
	pdftitle={\trabajo},
	pdfsubject={\materia},
	pdfauthor={\autores},
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\materia}
\fancyhead[R]{\trabajoheader - \trabajo}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}
	\pagenumbering{gobble}
	\pagenumbering{roman}
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	\begin{titlepage}
		\hfill\includegraphics[width=6cm]{fiuba.jpeg}
		\begin{center}
			\vfill
			\Huge \textbf{\trabajo}
			\vskip2cm
			\Large \materia\\
			\cuatrimestre
			\vfill
			\grupo
			\begin{itemize}
				\item Camila Bojman 101055 camiboj@gmail.com
				\item Cecilia Hortas 100687 ceci.hortas@gmail.com
				\item Nicolas Vazquez 100338 vazquez.nicolas.daniel@gmail.com
			\end{itemize}
			\vskip1cm
		\end{center}
	\end{titlepage}

\section{Requerimientos de software}

En primer lugar el programa fue desarrollado enteramente en C++ en un sistema operativo Linux por lo que los comandos que se detallarán a continuación son para ese sistema operativo y sus distribuciones afines. Las bibliotecas utilizadas se presentan a continuación:

\begin{itemize}
	\item \texttt{Box 2D}: se encuentra en el repositorio por lo que basta con clonar el mismo
\end{itemize}

\begin{itemize}
	\item \texttt{Native JSON Benchmark}: igualmente se encuentra en el repositorio
\end{itemize}

\begin{itemize}
	\item \texttt{SDL}: se debe instalar a partir de los siguientes comandos:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-dev
sudo apt-get install libsdl2-image-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{SDL-mixer}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-mixer-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{YAML}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libyaml-cpp-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{TTF}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-ttf-dev
\end{verbatim}

Agregar algo relativo al sh para la compilación

\section{Descripción general}

El proyecto se constituye de los siguientes módulos:

\begin{itemize}
	\item Servidor
	\item Cliente gráfico
	\item Editor
\end{itemize}

VER ESTO PORQUE NO SÉ QUÉ PONER

\section{Servidor}

\subsection{Descripción general}
Las funcionalidades del servidor se dividen en dos partes:
\begin{enumerate}
	\item Las relativas al motor físico, es decir, el modelado físico del juego.
	\item Las relativas al manejo de threading y sockets para brindar un soporte multijugador y multipartida.
\end{enumerate}

A continuación se enumeran las principales clases que se encargan de implementar dichas funcionalidades y sus principales atributos y métodos.

\subsection{Clases}

Para describir las clases utilizadas se dividirán las clases en 5 categorías:
\begin{itemize}
	\item Soporte de comunicación (threading y sockets)
	\item Entidades del juego
	\item Manejo de portales
	\item Manejo del escenario
	\item Movimientos del juego
\end{itemize} 

\subsubsection{Soporte de comunicación}

Estas clases se realizaron para modelar la comunicación con el cliente. Son las que encapsulan la comunicación por medio de sockets y el manejo de threads para brindar el soporte multipartida y multijugador del juego.

\begin{itemize}
	\item \textbf{Stage Manager}
\end{itemize}

Se encarga de controlar todo lo relativo al escenario y la partida a crear. Tiene como principales atributos una cantidad máxima de jugadores, una referencia al escenario de partida, un parser que se encarga de manejar el archivo \texttt{YAML} que contiene la información de los niveles a utilizar, una cola de eventos y una cola de clientes que contiene el estado actual de los mapas.  Cabe destacar que esta clase es la que se encarga de manejar los eventos de usuario y traducirlos a eventos en el mundo físico.

\begin{itemize}
	\item \textbf{Room Worker}
\end{itemize}

Esta clase se encarga de manejar la creación y la unión de partidas. Por lo tanto, es necesario que mantenga una referencia al socket del cliente, a su respectivo protocolo que encapsula la comunicación y a la clase \texttt{Room Manager} que se encarga de brindar los recursos necesarios para llevar esto a cabo.

\begin{itemize}
	\item \textbf{Room Manager}
\end{itemize}

Esta clase se encarga de organizar las diversas partidas creadas, agregar los jugadores a las mismas y remover las partidas que finalizaron.

\begin{itemize}
	\item \textbf{Room Acceptor}
\end{itemize}

Esta clase se utiliza para encapsular la aceptación de los clientes al servidor por lo que tiene como principal atributo un vector de punteros a la clase \texttt{Room Worker} para lanzarlos con el método \texttt{start} para inicializar los threads.

\begin{itemize}
	\item \textbf{Client Sender}
\end{itemize}

Esta clase se encarga de mandar a los clientes el estado actual del mundo físico por lo que sus atributos son referencias al socket del cliente y su protocolo así como una cola que guarda el estado actual del escenario.

\begin{itemize}
	\item \textbf{Client Receiver}
\end{itemize}

Esta clase se encarga de recibir los eventos de usuario para luego manejarlos por lo que mantiene una referencia al socket del cliente y una cola de eventos de usuario para encolar la serie de eventos recibidos.

\begin{itemize}
	\item \textbf{Client Handler}
\end{itemize}

Esta clase se encarga de manejar e inicializar las clases \texttt{Client Sender} y \texttt{Client Receiver} por lo que debe tener como atributos una referencia al socket del cliente y tanto una cola de eventos de usuario como una cola de estados actuales del escenario.
	
\subsubsection{Entidades del juego}

Se realizó una clase para cada elemento del juego de manera de modelizar sus responsabilidades y además se agregaron otras clases para hacer uso del polimorfismo y herencia de C++.

Es pertinente aclarar como elemento base del modelo que se utiliza una clase \texttt{Entity} de la cual derivan todas las clases de esta sección para poder modelizar las colisiones entre objetos. De esta manera, en caso de ocurrir una colisión, siempre sucede entre dos objetos de la clase \texttt{Entity} y por medio de la herencia se pudo manejar cada caso en particular con la sobreescritura de un método llamado \texttt{handleCollisions}. 

\begin{itemize}
	\item \textbf{Entity}
\end{itemize}

Tiene como atributos un string que denota el tipo de objeto y un puntero a un objeto de tipo \texttt{b2Body} de la libería Box2D. Tiene el método virtual puro \texttt{void handleCollision(Entity* entity)} para que lo implementen las clases derivadas y hagan un correcto manejo de colisiones.

\begin{itemize}
	\item \textbf{Acid}
\end{itemize}

Su principal método consiste en contempla las colisiones con instancias de la clase \texttt{Chell} ya que debe matarla.

\begin{itemize}
	\item \textbf{Shot}
\end{itemize}

Esta clase se encarga de modelizar el disparo. Tiene como atributos dos punteros a la clase \texttt{Coordinate} (que representa una coordenada) tanto para el origen como el destino del disparo, un booleano que indica si finalizó el recorrido, un ángulo de disparo y un puntero a la clase \texttt{Chell} para poder asignarle los portales creados a la misma.

\begin{itemize}
	\item \textbf{Blue Shot}
\end{itemize}

Esta clase hereda de la clase \texttt{Shot} y maneja la colisión con un bloque de metal ya que debe crear un portal sobre el mismo de color azul.

\begin{itemize}
	\item \textbf{Orange Shot}
\end{itemize}

Esta clase hereda de la clase \texttt{Shot} y maneja la colisión con un bloque de metal ya que debe crear un portal sobre el mismo de color naranja.

\begin{itemize}
	\item \textbf{Cake}
\end{itemize}

Esta clase principalmente maneja las colisiones con objetos de la clase \texttt{Chell} ya que debe ganar en caso de colisionar.

\begin{itemize}
	\item \textbf{Chell}
\end{itemize}

Esta clase tiene como atributos un puntero al objeto que alberga el portal naranja, otro al objeto que alberga el portal azul y dos punteros a la clase \texttt{Coordinate} que representan los dos portales a teletransportarse. Además guarda un puntero a la clase \texttt{PinTool} y a la clase \texttt{Rock} en caso de estar agarrando una roca. Sus principales métodos implican moverse a la derecha, moverse a la izquierda, saltar, agarrar una roca y dejarla, agregar los portales una vez realizados y contemplar los diversos casos de colisión con el resto de los objetos,

\begin{itemize}
	\item \textbf{Diagonal Metal Block}
\end{itemize}

Esta clase tiene como atributo el ángulo de rotación para representar los cuatro bloques en diagonal y su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Energy Ball} para que cambie su dirección en caso de colisionar.

\begin{itemize}
	\item \textbf{Metal Block}
\end{itemize}

Esta clase tiene como responsabilidad principal manejar las colisiones con las bolas de energía para invertir su sentido y además con los disparos \texttt{Blue Shot} y \texttt{Orange Shot} para generar los portales.

\begin{itemize}
	\item \textbf{Rock Block}
\end{itemize}

Esta clase se encarga principalmente de manejar las colisiones con las bolas de energía para que desaparezcan y con los disparos para no generar portales en caso de colisionar.

\begin{itemize}
	\item \textbf{Energy Ball}
\end{itemize}

Esta clase tiene como método principal el que consiste en volar de acuerdo a la dirección establecida por el emisor de energía y además cambiar su dirección en caso de colisionar con un objeto de la clase \texttt{Diagonal Block} o rebotar en caso de colisionar con un objeto de la clase \texttt{Metal Block}.

\begin{itemize}
	\item \textbf{Energy Transmitter}
\end{itemize}

Esta clase se encarga principalmente de controlar la frecuencia de lanzamiento de las bolas de energía. De esta clase derivan las otras cuatro clases que designan las cuatro direcciones posibles que pueden tomar las bolas de energía (arriba, abajo, izquierda o derecha).

\begin{itemize}
	\item \textbf{Energy Bar}
\end{itemize}

Esta clase principalmente maneja las colisiones con los disparos y con las rocas para evitar el traspaso de las mismas.


\begin{itemize}
	\item \textbf{Gate}
\end{itemize}

Esta clase tiene como atributos un string que designa la lógica que debe seguirse para abrir la puerta y además un mapa que guarda los distintos botones involucrados en dicha lógica con su id como clave y un puntero al objeto \texttt{Button} como valor. Su principal método es el encargado de determinar si la puerta está abierta o cerrada de acuerdo al estado actual de los botones (encendido y apagado).

\begin{itemize}
	\item \textbf{Item Activable}
\end{itemize}

Esta clase fue implementada para que los dos objetos que pueden ser encendidos del escenario puedan heredar de ella. Por lo tanto, sus principales métodos consisten en activarlos, desactivarlos y determinar su estado.

\begin{itemize}
	\item \textbf{Button}
\end{itemize}

Esta clase hereda de la clase \texttt{Item Activable}. Su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Chell} y \texttt{Rock} para poder determinar su estado (encendido u apagado), guardado como atributo.

\begin{itemize}
	\item \textbf{Energy Receptor}
\end{itemize}

Esta clase hereda de la clase \texttt{Item Activable}. Su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Energy Ball} para poder determinar su estado (encendido u apagado), guardado como atributo.

\begin{itemize}
	\item \textbf{Portal}
\end{itemize}

Esta clase tiene como atributo un enum de tipo \texttt{Orientation} que designa la orientación vertical u horizontal del portal y un enum de tipo \texttt{Direction} que designa la dirección en que deben salir los objetos al teletransportarse por el otro portal, es decir, izquierda, derecha, abajo o arriba. Se encarga de manejar las colisiones con los objetos de la clase \texttt{Chell}, \texttt{Energy Ball} y \texttt{Rock} para que se teletransporten al topar con un portal.

\begin{itemize}
	\item \textbf{Rock}
\end{itemize}

Esta clase tiene como atributos un booleano que designa si está vivo o muerto y otro para designar si está siendo agarrado o no por Chell. Su principal método consiste en manejar las colisiones con los diversos objetos del mundo, por ejemplo, un objeto de la clase \texttt{Button} para activarlo, de la clase \texttt{Chel}l para matarla si está por encima de ella y morir en caso de topar con un objeto de la clase \texttt{Energy Bar}.

\begin{itemize}
	\item \textbf{PinTool}
\end{itemize}

Esta clase tiene como método principal el que consiste en eliminar el objeto del escenario luego de pasado cierto tiempo predefenido.

\subsubsection{Manejo de portales}

Esta sección tiene las clases que se utilizan para designar los portales en el escenario. Es necesario seguir una cierta organización para unir los portales a un objeto de la clase \texttt{Chell} en particular, borrar un portal de un color en caso de crearse otro del mismo color y resetear los portales (borarlos del escenario). Las clases que se encargan de dichas responsabilidades son las que siguen:

\begin{itemize}
	\item \textbf{Portal Holder}
\end{itemize}

Esta clase guarda como atributos un puntero a la clase \texttt{Coordinate} que representa las coordenadas de un portal, un enum \texttt{Orientation} que designa su orientación (vertical u horizontal) y un enum \texttt{Direction} que indica para donde deben teletransportarse los objetos en caso de toparse con su portal contrario.

\begin{itemize}
	\item \textbf{Portal Manager}
\end{itemize}

Esta clase tiene como atributos una referencia a un \texttt{unordered\_map} que tiene como claves los ids como string de los portales y como valor un puntero al objeto de la clase \texttt{Portal}, además de una referencia al objeto de clase \texttt{Stage}. De esta manera se encarga de eliminar los portales del mundo y de crearlos de acuerdo a los portales actuales de la clase \texttt{Chell}.

\subsubsection{Manejo del escenario}

Estas clases son las encargadas de la organización global de los objetos en el escenario, su disposición en el escenario y su representación en \texttt{Box2D}.

\begin{itemize}
	\item \textbf{Coordinates}
\end{itemize}
Esta clase guarda dos atributos de tipo \texttt{float} que representan las coordenadas \texttt{x} e \texttt{y}.

\begin{itemize}
	\item \textbf{Physics World}
\end{itemize}
Esta clase se encarga de encapsular la creación de objetos en el mundo de \texttt{Box2D}. Por eso sus atributos son un puntero a un objeto de tipo \texttt{b2World} y el ancho y el largo del escenario como \texttt{floats}. Los principales métodos consisten en agregar rectángulos estáticos y dinámicos al escenario, triángulos estáticos y el caso particular para el objeto de la clase \texttt{Chell}: un rectangulo con dos ruedas en su parte inferior. Esto tuvo que realizarse para evitar que el objeto se trabe en los diversos rectángulos simulados como piso. Además, se encarga de la correcta destrucción de los objetos en el mundo y de simular el \textit{step} de \texttt{Box2D}.

\begin{itemize}
	\item \textbf{Stage}
\end{itemize}

Esta clase tiene como atributos una serie de \texttt{unordered\_map} donde se guardan todos los objetos del mundo como valor y como clave un id de clase \texttt{string} o un objeto de la clase \texttt{Coordinate} para el caso de los bloques estáticos. Su principal método es el que simula el \texttt{step} y llama a los diversos métodos que deben convocarse en cada llamada a la modelación del mundo físico. Además tiene un método que devuelve el \texttt{json} necesario para actualizar las vistas de los diversos clientes.

\begin{itemize}
	\item \textbf{Yaml Parser}
\end{itemize}
Esta clase es la encargada de unir el editor y el servidor. Tiene como atributos un nodo \texttt{YAML} y una referencia al \texttt{Stage}. De esta manera, lee el archivo \texttt{YAML} generado por el editor, agrega los objetos que debe agregar al escenario y genera los \texttt{json} pertinentes para inicializar las vistas.

\subsubsection{Movimientos del juego}

Estas clases se realizaron para designar los movimientos básicos de Chell y la roca. Se siguió una implementación en la que cada clase en su método de actualización llamada al método \texttt{move()}, sin importar qué clase se está llamando. De esta manera, las clases que simulan el movimiento \texttt{Move Right}, \texttt{Move Left} y \texttt{Stop} heredan de una clase \texttt{Dynamic} y sobreescriben el método \texttt{move()}.

La clase \texttt{Dynamic} alberga la responsabilidad de simular desde la física el salto de Chell, los movimientos de las piedras y todo lo relativo al vuelo de las bolas de energía así como el manejo de colisiones de los objetos y la teletransportación de los mismos al toparse con un portal.

\subsection{Diagramas UML}

\subsection{Descripción de archivos y protocolos}

El protocolo implementado consistió en enviar y recibir \texttt{strings} por medio de sockets utilizando el protocolo \texttt{TCP}. Estos strings provenían de objetos de la clase \texttt{nlohmann::json}, implementada por la librería \texttt{nlohman} \footnote{https://github.com/nlohmann/json} que tienen un método de conversión a strings. Para el envío de strings se envía primero el largo del string y luego el string. Para recibir simplemente se recibe un string.

La idea utilizada consistió en inicialmente mandar tres jsons de estado:
\begin{enumerate}
	\item Metadata: largo y ancho del escenario:
	\begin{verbatim}
	json[id] = {
		 {"height", height}, {"width", width}
	};
	\end{verbatim}
	\item Data de objetos estáticos (bloques metálicos, bloques en diagonal y bloques de roca):
	\begin{verbatim}
		json[id] = {
			{"type", NAME}, {"x", x}, {"y", y}
	};
	\end{verbatim}
	La constante \texttt{NAME} varia para cada objeto y fue definida en un archivo de uso compartido \texttt{constants.h}.
	\item Data de objetos dinámicos (todo el resto de los objetos). Se trata de los objetos que fueron designados con un id en particular:
	\begin{verbatim}
			json[id] = {
	{"state", state}, {type", NAME}, {"x", x}, {"y", y}
	};
	\end{verbatim}
	Nuevamente la constante \texttt{NAME} se trata de un \texttt{int} definido en el archivo \texttt{constants.h} y el estado se designa de acuerdo al tipo de objeto. Hay objetos que no tienen estado pero la gran mayoría sí:
	\begin{itemize}
		\item Chell: IDLE, JUMPING, MOVING RIGHT, MOVING LEFT
		\item Portal: HORIZONTAL o VERTICAL
		\item Button: ON o OFF
		\item Receptor: ON o OFF
		\item Energy Bar: HORIZONTAL o VERTICAL
		\item Gate: OPEN o CLOSED
	\end{itemize}
\end{enumerate}

Luego, en cada \texttt{step} simulado por \texttt{Box2D} se envía al cliente un \texttt{json} en forma de \texttt{string} como el último descrito, es decir, con la actualización de los objetos dinámicos en el mundo físico.

\section{Cliente}

\subsection{Descripción general}

\subsection{Clases}

\subsection{Diagramas UML}

\subsection{Descripción de archivos y protocolos}

\section{Editor}

\subsection{Descripción general}

\subsection{Clases}

\subsection{Diagramas UML}

\subsection{Descripción de archivos y protocolos}

\section{Programas intermedios y de prueba}

\section{Código fuente}


\end{document}