\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr,graphicx}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}

\newcommand{\materia}{[75.41] Taller de Programación I}
\newcommand{\trabajo}{Documentación técnica}
\newcommand{\trabajoheader}{Ejercicio final }
\newcommand{\cuatri}{1c2019}
\newcommand{\cuatrimestre}{Primer cuatrimestre de 2019}
\newcommand{\grupo}{Grupo 3}

\newcommand{\autores}{
	Camila Bojman,
	Cecilia Hortas,
	Nicolas Vazquez}

\hypersetup{
	pdftitle={\trabajo},
	pdfsubject={\materia},
	pdfauthor={\autores},
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\materia}
\fancyhead[R]{\trabajoheader - \trabajo}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}
	\pagenumbering{gobble}
	\pagenumbering{roman}
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	\begin{titlepage}
		\hfill\includegraphics[width=6cm]{fiuba.jpeg}
		\begin{center}
			\vfill
			\Huge \textbf{\trabajo}
			\vskip2cm
			\Large \materia\\
			\cuatrimestre
			\vfill
			\grupo
			\begin{itemize}
				\item Camila Bojman 101055 camiboj@gmail.com
				\item Cecilia Hortas 100687 ceci.hortas@gmail.com
				\item Nicolas Vazquez 100338 vazquez.nicolas.daniel@gmail.com
			\end{itemize}
			\vskip1cm
		\end{center}
	\end{titlepage}

\section{Requerimientos de software}

En primer lugar el programa fue desarrollado enteramente en C++ en un sistema operativo Linux por lo que los comandos que se detallarán a continuación son para ese sistema operativo y sus distribuciones afines. Las bibliotecas utilizadas se presentan a continuación:

\begin{itemize}
	\item \texttt{Box 2D}: se encuentra en el repositorio por lo que basta con clonar el mismo
\end{itemize}

\begin{itemize}
	\item \texttt{Native JSON Benchmark}: igualmente se encuentra en el repositorio
\end{itemize}

\begin{itemize}
	\item \texttt{SDL}: se debe instalar a partir de los siguientes comandos:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-dev
sudo apt-get install libsdl2-image-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{SDL-mixer}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-mixer-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{YAML}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libyaml-cpp-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{TTF}: se debe instalar a partir del siguiente comando:
\end{itemize}

\begin{verbatim}
sudo apt-get install libsdl2-ttf-dev
\end{verbatim}

\begin{itemize}
	\item \texttt{ffmpeg}: se debe instalar a partir de los siguientes comandos:
	
\begin{verbatim}
	sudo apt install libavutil libswresample libavformat libavcodec
	sudo apt-get install ffmpeg
\end{verbatim}
\end{itemize}

\begin{itemize}
	\item \texttt{CMake}: se debe instalar a partir de los siguientes comandos:
	\footnote{Fuente: https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line}
	
	\begin{enumerate}
		\item Desinstalar cualquier versión previa de CMake:
		\begin{verbatim}
		sudo apt remove --purge --auto-remove cmake
		\end{verbatim}
		\item Ir a la página oficial de CMake y bajar la última versión: 
		\begin{verbatim}
		http://www.cmake.org/download
		\end{verbatim}
		\item Correr los siguientes comandos:
		\begin{verbatim}
		$ version=3.14
		$ build=5
		$ mkdir ~/temp
		$ cd ~/temp
		$ wget https://cmake.org/files/v$version/cmake-$version.$build.tar.gz
		$ tar -xzvf cmake-$version.$build.tar.gz
		$ cd cmake-$version.$build/
		$ ./bootstrap
		$ make -j4
		$ sudo make install
		\end{verbatim}
		\item Verificar la versión de CMake:
		\begin{verbatim}
		$ cmake --version
		cmake version 3.14.X
		\end{verbatim}
	\end{enumerate}
\end{itemize}

\subsection{Instalación}
En el \texttt{root} del repositorio clonado se encuentra un archivo \texttt{install.sh}. Para realizar la instalación se deben seguir los siguientes pasos:

\begin{verbatim}
chmod +x install.sh
./install.sh <path>
\end{verbatim}
donde \texttt{<path>} es el directorio donde se desea instalar el juego.

Para proceder a jugar al juego se deben seguir los siguientes pasos:

\begin{enumerate}
	\item Levantar un servidor con el comando \texttt{./Server <port>}
	\item Conectarse con el cliente con \texttt{./Client <host> <port>} siendo \texttt{<host>} una dirección IP y \texttt{<port>} el mismo puerto del servidor.
\end{enumerate}

Para crear y editar mapas, ejecutar \texttt{./Editor}.

\section{Descripción general}

El proyecto se constituye de los siguientes módulos:

\begin{itemize}
	\item \textbf{Servidor}

Se encuentran tanto las clases designadas al soporte físico del juego como al soporte multijugador y multipartida.

	\item \textbf{Cliente gráfico}
	
Se encuentran las clases designadas para modelar el cliente desde un lado gráfico con el uso de la librería \texttt{SDL} así como el soporte para manejar la recepción del estado actual del escenario para dibujarlo y el envío de los diversos eventos de usuarios para que sean modelados por el motor físico.
	\item \textbf{Editor}
	
Se encuentran las clases designadas para el modelado del editor que se tratan escencialmente de \textit{wrappers} de diversas funcionalidades de \texttt{SDL} y \texttt{ffmpeg}.

	\item \textbf{Archivos compartidos}
	
Se tratan de diversas clases que se consideró que podían ser útiles para más de un módulo por lo que se colocaron en un espacio común para su correcta compilación.
\end{itemize}

\section{Archivos compartidos}

Se tratan de clases que no necesariamente están relacionadas entre sí por lo que se considera que no es pertinente a la documentación exponer un diagrama de clases. Sin embargo, sí se mostrará su relación con las futuras clases. De esta forma, las principales clases que componen este módulo son:

\begin{itemize}
	\item \textbf{Socket}
\end{itemize}

Esta clase encapsula todas las operaciones realizadas para la comunicación a través de un socket.

\begin{itemize}
	\item \textbf{Protocol}
\end{itemize}

Esta clase encapsula el protócolo utilizado para el desarrollo del juego. Contiene una referencia a un \texttt{Socket} y modela el envío y recepción de \texttt{strings}.

\begin{itemize}
	\item \textbf{Thread}
\end{itemize}

Esta clase encapsula el funcionamiento de un thread. Su principal atributo es una variable de tipo \texttt{std::thread} a la que se le pasa como parámetro una
referencia a la función \texttt{run()} que encapsula la ejecución.

\begin{itemize}
	\item \textbf{UserEventQueue}
\end{itemize}

Se trata de una cola bloqueante a la que se encola los diversos eventos de usuarios que deben ser modelados por el motor físico.

\begin{itemize}
	\item \textbf{StageStatusQueue}
\end{itemize}

Se trata de una cola bloqueante a la que se encola el estado del escenario en un step dado por el escenario para que sea dibujado por los diversos clientes.

\section{Servidor}

\subsection{Descripción general}
Las funcionalidades del servidor se dividen en dos partes:
\begin{enumerate}
	\item Las relativas al motor físico, es decir, el modelado físico del juego.
	\item Las relativas al manejo de threading y sockets para brindar un soporte multijugador y multipartida.
\end{enumerate}

A continuación se enumeran las principales clases que se encargan de implementar dichas funcionalidades y sus principales atributos y métodos.

\subsection{Clases}

Para describir las clases utilizadas se dividirán las clases en 5 categorías:
\begin{itemize}
	\item Soporte de comunicación (threading y sockets)
	\item Entidades del juego
	\item Manejo de portales
	\item Manejo del escenario
	\item Movimientos del juego
\end{itemize} 

\subsubsection{Soporte de comunicación}

Estas clases se realizaron para modelar la comunicación con el cliente. Son las que encapsulan la comunicación por medio de sockets y el manejo de threads para brindar el soporte multipartida y multijugador del juego.

\begin{itemize}
	\item \textbf{Stage Manager}
\end{itemize}

Se encarga de controlar todo lo relativo al escenario y la partida a crear. Tiene como principales atributos una cantidad máxima de jugadores, una referencia al escenario de partida, un parser que se encarga de manejar el archivo \texttt{YAML} que contiene la información de los niveles a utilizar, una cola de eventos y una cola de clientes que contiene el estado actual de los mapas.  Cabe destacar que esta clase es la que se encarga de manejar los eventos de usuario y traducirlos a eventos en el mundo físico.

\begin{itemize}
	\item \textbf{Room Worker}
\end{itemize}

Esta clase se encarga de manejar la creación y la unión de partidas. Por lo tanto, es necesario que mantenga una referencia al socket del cliente, a su respectivo protocolo que encapsula la comunicación y a la clase \texttt{Room Manager} que se encarga de brindar los recursos necesarios para llevar esto a cabo.

\begin{itemize}
	\item \textbf{Room Manager}
\end{itemize}

Esta clase se encarga de organizar las diversas partidas creadas, agregar los jugadores a las mismas y remover las partidas que finalizaron.

\begin{itemize}
	\item \textbf{Room Acceptor}
\end{itemize}

Esta clase se utiliza para encapsular la aceptación de los clientes al servidor por lo que tiene como principal atributo un vector de punteros a la clase \texttt{Room Worker} para lanzarlos con el método \texttt{start} para inicializar los threads.

\begin{itemize}
	\item \textbf{Client Sender}
\end{itemize}

Esta clase se encarga de mandar a los clientes el estado actual del mundo físico por lo que sus atributos son referencias al socket del cliente y su protocolo así como una cola que guarda el estado actual del escenario.

\begin{itemize}
	\item \textbf{Client Receiver}
\end{itemize}

Esta clase se encarga de recibir los eventos de usuario para luego manejarlos por lo que mantiene una referencia al socket del cliente y una cola de eventos de usuario para encolar la serie de eventos recibidos.

\begin{itemize}
	\item \textbf{Client Handler}
\end{itemize}

Esta clase se encarga de manejar e inicializar las clases \texttt{Client Sender} y \texttt{Client Receiver} por lo que debe tener como atributos una referencia al socket del cliente y tanto una cola de eventos de usuario como una cola de estados actuales del escenario.
	
\subsubsection{Entidades del juego}

Se realizó una clase para cada elemento del juego de manera de modelizar sus responsabilidades y además se agregaron otras clases para hacer uso del polimorfismo y herencia de C++.

Es pertinente aclarar como elemento base del modelo que se utiliza una clase \texttt{Entity} de la cual derivan todas las clases de esta sección para poder modelizar las colisiones entre objetos. De esta manera, en caso de ocurrir una colisión, siempre sucede entre dos objetos de la clase \texttt{Entity} y por medio de la herencia se pudo manejar cada caso en particular con la sobreescritura de un método llamado \texttt{handleCollisions}. 

\begin{itemize}
	\item \textbf{Entity}
\end{itemize}

Tiene como atributos un string que denota el tipo de objeto y un puntero a un objeto de tipo \texttt{b2Body} de la libería Box2D. Tiene el método virtual puro \texttt{void handleCollision(Entity* entity)} para que lo implementen las clases derivadas y hagan un correcto manejo de colisiones.

\begin{itemize}
	\item \textbf{Acid}
\end{itemize}

Su principal método consiste en contempla las colisiones con instancias de la clase \texttt{Chell} ya que debe matarla.

\begin{itemize}
	\item \textbf{Shot}
\end{itemize}

Esta clase se encarga de modelizar el disparo. Tiene como atributos dos punteros a la clase \texttt{Coordinate} (que representa una coordenada) tanto para el origen como el destino del disparo, un booleano que indica si finalizó el recorrido, un ángulo de disparo y un puntero a la clase \texttt{Chell} para poder asignarle los portales creados a la misma.

\begin{itemize}
	\item \textbf{Blue Shot}
\end{itemize}

Esta clase hereda de la clase \texttt{Shot} y maneja la colisión con un bloque de metal ya que debe crear un portal sobre el mismo de color azul.

\begin{itemize}
	\item \textbf{Orange Shot}
\end{itemize}

Esta clase hereda de la clase \texttt{Shot} y maneja la colisión con un bloque de metal ya que debe crear un portal sobre el mismo de color naranja.

\begin{itemize}
	\item \textbf{Cake}
\end{itemize}

Esta clase principalmente maneja las colisiones con objetos de la clase \texttt{Chell} ya que debe ganar en caso de colisionar.

\begin{itemize}
	\item \textbf{Chell}
\end{itemize}

Esta clase tiene como atributos un puntero al objeto que alberga el portal naranja, otro al objeto que alberga el portal azul y dos punteros a la clase \texttt{Coordinate} que representan los dos portales a teletransportarse. Además guarda un puntero a la clase \texttt{PinTool} y a la clase \texttt{Rock} en caso de estar agarrando una roca. Sus principales métodos implican moverse a la derecha, moverse a la izquierda, saltar, agarrar una roca y dejarla, agregar los portales una vez realizados y contemplar los diversos casos de colisión con el resto de los objetos,

\begin{itemize}
	\item \textbf{Diagonal Metal Block}
\end{itemize}

Esta clase tiene como atributo el ángulo de rotación para representar los cuatro bloques en diagonal y su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Energy Ball} para que cambie su dirección en caso de colisionar.

\begin{itemize}
	\item \textbf{Metal Block}
\end{itemize}

Esta clase tiene como responsabilidad principal manejar las colisiones con las bolas de energía para invertir su sentido y además con los disparos \texttt{Blue Shot} y \texttt{Orange Shot} para generar los portales.

\begin{itemize}
	\item \textbf{Rock Block}
\end{itemize}

Esta clase se encarga principalmente de manejar las colisiones con las bolas de energía para que desaparezcan y con los disparos para no generar portales en caso de colisionar.

\begin{itemize}
	\item \textbf{Energy Ball}
\end{itemize}

Esta clase tiene como método principal el que consiste en volar de acuerdo a la dirección establecida por el emisor de energía y además cambiar su dirección en caso de colisionar con un objeto de la clase \texttt{Diagonal Block} o rebotar en caso de colisionar con un objeto de la clase \texttt{Metal Block}.

\begin{itemize}
	\item \textbf{Energy Transmitter}
\end{itemize}

Esta clase se encarga principalmente de controlar la frecuencia de lanzamiento de las bolas de energía. De esta clase derivan las otras cuatro clases que designan las cuatro direcciones posibles que pueden tomar las bolas de energía (arriba, abajo, izquierda o derecha).

\begin{itemize}
	\item \textbf{Energy Bar}
\end{itemize}

Esta clase principalmente maneja las colisiones con los disparos y con las rocas para evitar el traspaso de las mismas.


\begin{itemize}
	\item \textbf{Gate}
\end{itemize}

Esta clase tiene como atributos un string que designa la lógica que debe seguirse para abrir la puerta y además un mapa que guarda los distintos botones involucrados en dicha lógica con su id como clave y un puntero al objeto \texttt{Button} como valor. Su principal método es el encargado de determinar si la puerta está abierta o cerrada de acuerdo al estado actual de los botones (encendido y apagado).

\begin{itemize}
	\item \textbf{Item Activable}
\end{itemize}

Esta clase fue implementada para que los dos objetos que pueden ser encendidos del escenario puedan heredar de ella. Por lo tanto, sus principales métodos consisten en activarlos, desactivarlos y determinar su estado.

\begin{itemize}
	\item \textbf{Button}
\end{itemize}

Esta clase hereda de la clase \texttt{Item Activable}. Su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Chell} y \texttt{Rock} para poder determinar su estado (encendido u apagado), guardado como atributo.

\begin{itemize}
	\item \textbf{Energy Receptor}
\end{itemize}

Esta clase hereda de la clase \texttt{Item Activable}. Su principal método consiste en manejar las colisiones con los objetos de la clase \texttt{Energy Ball} para poder determinar su estado (encendido u apagado), guardado como atributo.

\begin{itemize}
	\item \textbf{Portal}
\end{itemize}

Esta clase tiene como atributo un enum de tipo \texttt{Orientation} que designa la orientación vertical u horizontal del portal y un enum de tipo \texttt{Direction} que designa la dirección en que deben salir los objetos al teletransportarse por el otro portal, es decir, izquierda, derecha, abajo o arriba. Se encarga de manejar las colisiones con los objetos de la clase \texttt{Chell}, \texttt{Energy Ball} y \texttt{Rock} para que se teletransporten al topar con un portal.

\begin{itemize}
	\item \textbf{Rock}
\end{itemize}

Esta clase tiene como atributos un booleano que designa si está vivo o muerto y otro para designar si está siendo agarrado o no por Chell. Su principal método consiste en manejar las colisiones con los diversos objetos del mundo, por ejemplo, un objeto de la clase \texttt{Button} para activarlo, de la clase \texttt{Chel}l para matarla si está por encima de ella y morir en caso de topar con un objeto de la clase \texttt{Energy Bar}.

\begin{itemize}
	\item \textbf{PinTool}
\end{itemize}

Esta clase tiene como método principal el que consiste en eliminar el objeto del escenario luego de pasado cierto tiempo predefenido.

\subsubsection{Manejo de portales}

Esta sección tiene las clases que se utilizan para designar los portales en el escenario. Es necesario seguir una cierta organización para unir los portales a un objeto de la clase \texttt{Chell} en particular, borrar un portal de un color en caso de crearse otro del mismo color y resetear los portales (borarlos del escenario). Las clases que se encargan de dichas responsabilidades son las que siguen:

\begin{itemize}
	\item \textbf{Portal Holder}
\end{itemize}

Esta clase guarda como atributos un puntero a la clase \texttt{Coordinate} que representa las coordenadas de un portal, un enum \texttt{Orientation} que designa su orientación (vertical u horizontal) y un enum \texttt{Direction} que indica para donde deben teletransportarse los objetos en caso de toparse con su portal contrario.

\begin{itemize}
	\item \textbf{Portal Manager}
\end{itemize}

Esta clase tiene como atributos una referencia a un \texttt{unordered\_map} que tiene como claves los ids como string de los portales y como valor un puntero al objeto de la clase \texttt{Portal}, además de una referencia al objeto de clase \texttt{Stage}. De esta manera se encarga de eliminar los portales del mundo y de crearlos de acuerdo a los portales actuales de la clase \texttt{Chell}.

\subsubsection{Manejo del escenario}

Estas clases son las encargadas de la organización global de los objetos en el escenario, su disposición en el escenario y su representación en \texttt{Box2D}.

\begin{itemize}
	\item \textbf{Coordinates}
\end{itemize}
Esta clase guarda dos atributos de tipo \texttt{float} que representan las coordenadas \texttt{x} e \texttt{y}.

\begin{itemize}
	\item \textbf{Physics World}
\end{itemize}
Esta clase se encarga de encapsular la creación de objetos en el mundo de \texttt{Box2D}. Por eso sus atributos son un puntero a un objeto de tipo \texttt{b2World} y el ancho y el largo del escenario como \texttt{floats}. Los principales métodos consisten en agregar rectángulos estáticos y dinámicos al escenario, triángulos estáticos y el caso particular para el objeto de la clase \texttt{Chell}: un rectangulo con dos ruedas en su parte inferior. Esto tuvo que realizarse para evitar que el objeto se trabe en los diversos rectángulos simulados como piso. Además, se encarga de la correcta destrucción de los objetos en el mundo y de simular el \textit{step} de \texttt{Box2D}.

\begin{itemize}
	\item \textbf{Stage}
\end{itemize}

Esta clase tiene como atributos una serie de \texttt{unordered\_map} donde se guardan todos los objetos del mundo como valor y como clave un id de clase \texttt{string} o un objeto de la clase \texttt{Coordinate} para el caso de los bloques estáticos. Su principal método es el que simula el \texttt{step} y llama a los diversos métodos que deben convocarse en cada llamada a la modelación del mundo físico. Además tiene un método que devuelve el \texttt{json} necesario para actualizar las vistas de los diversos clientes.

\begin{itemize}
	\item \textbf{Yaml Parser}
\end{itemize}
Esta clase es la encargada de unir el editor y el servidor. Tiene como atributos un nodo \texttt{YAML} y una referencia al \texttt{Stage}. De esta manera, lee el archivo \texttt{YAML} generado por el editor, agrega los objetos que debe agregar al escenario y genera los \texttt{json} pertinentes para inicializar las vistas.

\subsubsection{Movimientos del juego}

Estas clases se realizaron para designar los movimientos básicos de Chell y la roca. Se siguió una implementación en la que cada clase en su método de actualización llamada al método \texttt{move()}, sin importar qué clase se está llamando. De esta manera, las clases que simulan el movimiento \texttt{Move Right}, \texttt{Move Left} y \texttt{Stop} heredan de una clase \texttt{Dynamic} y sobreescriben el método \texttt{move()}.

La clase \texttt{Dynamic} alberga la responsabilidad de simular desde la física el salto de Chell, los movimientos de las piedras y todo lo relativo al vuelo de las bolas de energía así como el manejo de colisiones de los objetos y la teletransportación de los mismos al toparse con un portal.

\subsection{Diagramas UML}

Se procede a exponer los diagramas de clase realizados para las diversas secciones:

\subsubsection{Entidades del juego}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=1.5\textwidth]{server_class_1.png}}
	\caption{Diagrama de clases de los elementos del juego}
	\label{fig:diagrama1}
\end{figure}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=1.5\textwidth]{server_class_2.png}}
	\caption{Diagrama de clases de los elementos del juego}
	\label{fig:diagrama2}
\end{figure}

\newpage
\subsubsection{Manejo de portales}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=0.65\textwidth]{server_class_3.png}}
	\caption{Diagrama de clases de los elementos utilizados para manejar los portales}
	\label{fig:diagrama3}
\end{figure}


\subsubsection{Manejo del escenario}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=0.25\textwidth]{server_class_4.png}}
	\caption{Diagrama de clases de los elementos utilizados para manejar el escenario}
	\label{fig:diagrama4}
\end{figure}

\subsubsection{Soporte de comunicación}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=0.75\textwidth]{server_class_5.png}}
	\caption{Diagrama de clases de los elementos utilizados para el soporte de comunicación}
	\label{fig:diagrama5}
\end{figure}

Es pertinente aclarar que no se mostró en el diagrama la relación con la clase \texttt{Protocol} y la clase \texttt{Socket} por claridad.
\newpage

\subsection{Descripción de archivos y protocolos}

El protocolo implementado consistió en enviar y recibir \texttt{strings} por medio de sockets utilizando el protocolo \texttt{TCP}. Estos strings provenían de objetos de la clase \texttt{nlohmann::json}, implementada por la librería \texttt{nlohman} \footnote{https://github.com/nlohmann/json} que tienen un método de conversión a strings. Para el envío de strings se envía primero el largo del string y luego el string. Para recibir simplemente se recibe un string.

La idea utilizada consistió en inicialmente mandar tres jsons de estado:
\begin{enumerate}
	\item Metadata: largo y ancho del escenario:
	\begin{verbatim}
	json[id] = {
		 {"height", height}, {"width", width}
	};
	\end{verbatim}
	\item Data de objetos estáticos (bloques metálicos, bloques en diagonal y bloques de roca):
	\begin{verbatim}
		json[id] = {
			{"type", NAME}, {"x", x}, {"y", y}
	};
	\end{verbatim}
	La constante \texttt{NAME} varia para cada objeto y fue definida en un archivo de uso compartido \texttt{constants.h}.
	\item Data de objetos dinámicos (todo el resto de los objetos). Se trata de los objetos que fueron designados con un id en particular:
	\begin{verbatim}
			json[id] = {
	{"state", state}, {type", NAME}, {"x", x}, {"y", y}
	};
	\end{verbatim}
	Nuevamente la constante \texttt{NAME} se trata de un \texttt{int} definido en el archivo \texttt{constants.h} y el estado se designa de acuerdo al tipo de objeto. Hay objetos que no tienen estado pero la gran mayoría sí:
	\begin{itemize}
		\item Chell: IDLE, JUMPING, MOVING RIGHT, MOVING LEFT
		\item Portal: HORIZONTAL o VERTICAL
		\item Button: ON o OFF
		\item Receptor: ON o OFF
		\item Energy Bar: HORIZONTAL o VERTICAL
		\item Gate: OPEN o CLOSED
	\end{itemize}
\end{enumerate}

Luego, en cada \texttt{step} simulado por \texttt{Box2D} se envía al cliente un \texttt{json} en forma de \texttt{string} como el último descrito, es decir, con la actualización de los objetos dinámicos en el mundo físico.

\section{Cliente}

\subsection{Descripción general}

La funcionalidad del cliente puede dividirse en tres grupos:
\begin{enumerate}
	\item Soporte para sonidos
	\item Soporte para vistas
	\item Soporte para comunicación con el servidor
\end{enumerate}

En la próxima sección se enumeran las diversas clases relacionadas con dichas funcionalidades.

\subsection{Clases}

\subsubsection{Soporte para sonidos}

\subsubsection{Soporte para vistas}

\subsubsection{Soporte para comunicación}

\begin{itemize}
	\item \textbf{Event Sender}
\end{itemize}

Sus atributos son un protocolo \texttt{Protocol} y una referencia a una cola de eventos de usuario \texttt{UserEventQueue}. Se encarga de enviar los diversos eventos de usuario al servidor, por medio del protocolo que encapsula el envío a través de sockets.

\begin{itemize}
	\item \textbf{State Status Receiver}
\end{itemize}

Sus atributos son un protocolo \texttt{Protocol} y una referencia a una cola de estados del escenario \texttt{StageStatusQueue}. Se encarga de recibir los diversos estados del escenario, enviados por el servidor, para dibujar los elementos dinámicos en su estado actual.

\begin{itemize}
	\item \textbf{User Event Handler}
\end{itemize}

Sus principales atributos son una referencia a la cola de sonidos \texttt{SoundCodeQueue} y a la cola de eventos de usuario \texttt{UserEventQueue}.

Se encarga de reproducir el sonido designado para cada evento y además decodificar cada input del teclado y del mouse en un código guardado como \texttt{int} para encolarlo en la cola de eventos.

\subsection{Diagramas UML}

\subsubsection{Soporte para sonidos}

\subsubsection{Soporte para vistas}

\subsubsection{Soporte para comunicación}

\begin{figure}[!h]
	\makebox[\textwidth][c]{\includegraphics[width=1\textwidth]{client_class_1.png}}
	\caption{Diagrama de clases del soporte de comunicación del cliente}
	\label{fig:diagram6}
\end{figure}

\subsection{Descripción de archivos y protocolos}

\section{Editor}

\subsection{Descripción general}

\subsection{Clases}

\subsection{Diagramas UML}

\subsection{Descripción de archivos y protocolos}


\end{document}